import{_ as e,o as t,c as d,a}from"./app-fr3Buw_y.js";const r={},n=a(`<h2 id="vue父组件和子组件的生命周期执行顺序" tabindex="-1"><a class="header-anchor" href="#vue父组件和子组件的生命周期执行顺序" aria-hidden="true">#</a> vue父组件和子组件的生命周期执行顺序</h2><p>##1.渲染过程顺序： 父组件beforeCreate() -&gt; 父组件created() -&gt; 父组件beforeMount() -&gt; 子组件beforeCreate() -&gt;子组件created() -&gt; 子组件beforeMount() -&gt; 子组件mounted() -&gt; 父组件mounted()</p><p>##父组件更新过程： 父组件beforeUpdate() -&gt; 父组件updated()</p><p>##子组件更新过程： 父组件beforeUpdate() -&gt; 子组件beforeUpdate() -&gt; 子组件updated() -&gt; 父组件updated()</p><p>##3.销毁过程 父组件beforeDestroy() -&gt; 子组件beforeDestroy() -&gt; 子组件destroyed() -&gt; 父组件destroyed()</p><p>##总结： 不管是哪种情况，都一定是父组件等待子组件完成后，才会执行自己对应完成的钩子</p><p>##拓展有同学问：</p><p>那个我要想在所有的页面渲染完毕后进行操作咋办？</p><p>你可以在mounted中：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>this.$nextTick(() =&gt; {
	//此时页面已经渲染完毕
	...
})
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,10),o=[n];function s(i,_){return t(),d("div",null,o)}const p=e(r,[["render",s],["__file","V007-vue父组件和子组件的生命周期执行顺序.html.vue"]]);export{p as default};
