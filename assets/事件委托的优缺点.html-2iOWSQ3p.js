import{_ as e,o as a,c as o,a as t}from"./app-fr3Buw_y.js";const c={},r=t('<h1 id="事件委托-事件代理-的原理以及优缺点是什么" tabindex="-1"><a class="header-anchor" href="#事件委托-事件代理-的原理以及优缺点是什么" aria-hidden="true">#</a> 事件委托（事件代理）的原理以及优缺点是什么？</h1><h3 id="事件委托原理-事件冒泡机制" tabindex="-1"><a class="header-anchor" href="#事件委托原理-事件冒泡机制" aria-hidden="true">#</a> 事件委托原理：事件冒泡机制；</h3><h2 id="优点" tabindex="-1"><a class="header-anchor" href="#优点" aria-hidden="true">#</a> 优点：</h2><blockquote><p>1、可以大量节省内存占用，减少事件注册。比如ul上代理所有li的click事件就很不错； (a.每一个事件处理函数，都是一个对象，多一个事件处理函数，内存中就会被多占用一部分空间。如果要用事件委托，就会将所有的操作放到 js 程序里面，只对它的父级进行操作，与 dom 的操作就只需要交互一次，这样就能大大的减少与 dom 的交互次数，提高性能； 减少了内存占用, 性能更好; b.在访问 DOM 方面, 也使得 DOM 访问次数减少试想一下, 如果要为许多的 DOM 元素绑定事件, 自然需要多次访问 DOM 元素, 设置事件处理程序所需时间更长, 整个页面就绪需要的时间越多因此第二个优点是: 设置事件处理程序所需时间更少, 加快了整个页面的交互就绪时间)</p></blockquote><blockquote><p>2、可以实现当新增子对象时，无需再对其进行事件绑定，对于动态内容部分尤为适合；</p></blockquote><h2 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点" aria-hidden="true">#</a> 缺点：</h2><blockquote><p>事件委托的实现依靠的冒泡，因此不支持事件冒泡的事件就不适合使用事件委托。 不是所有的事件绑定都适合使用事件委托，不恰当使用反而可能导致不需要绑定事件的元素也被绑定上了事件。</p></blockquote>',7),d=[r];function h(i,n){return a(),o("div",null,d)}const s=e(c,[["render",h],["__file","事件委托的优缺点.html.vue"]]);export{s as default};
