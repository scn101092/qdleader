import{_ as r,o as a,c,d as e,b as t}from"./app-fr3Buw_y.js";const o={},i=e("p",null,"import {isObject} from '@vue/shared'",-1),n=e("p",null,"export function reactive(target) { if(!isObject(target)) { return } const proxy = new Proxy(target,{ get(target,key,receiver) { // return target[key] return Reflect.get(target,key,receiver) }, set(target,key,value,receiver) { //target[key] = value return Reflect.set(target,key,value,receiver) } }) return proxy; }",-1),s=e("p",null,"未完待续",-1),_=e("h2",{id:"额外拓展",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#额外拓展","aria-hidden":"true"},"#"),t(" 额外拓展")],-1),l=e("h3",{id:"关于-reactive-和-ref-的对比",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#关于-reactive-和-ref-的对比","aria-hidden":"true"},"#"),t(" 关于 reactive 和 ref 的对比")],-1),d=e("p",null,"reactive vs ref",-1),u=e("blockquote",null,[e("p",null,"reactive参数一般接受对象或数组，是深层次的响应式。ref参数一般接收简单数据类型，若ref接收对象为参数，本质上会转变为reactive方法 在JS中访问ref的值需要手动添加.value，访问reactive不需要 reactive的底层响应式原理是Proxy，ref的原理是defineProperty")],-1),f=[i,n,s,_,l,d,u];function v(h,p){return a(),c("div",null,f)}const x=r(o,[["render",v],["__file","reactive的实现.html.vue"]]);export{x as default};
