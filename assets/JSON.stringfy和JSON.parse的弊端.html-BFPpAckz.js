const e=JSON.parse('{"key":"v-398e72c1","path":"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/js%E7%B1%BB/%E5%85%B6%E4%BB%96%E7%B1%BB/JSON.stringfy%E5%92%8CJSON.parse%E7%9A%84%E5%BC%8A%E7%AB%AF.html","title":"缺点","lang":"zh-CN","frontmatter":{},"headers":[{"level":3,"title":"1.如果obj里面有时间对象，则JSON.stringify后再JSON.parse的结果，时间将只是字符串的形式，而不是对象的形式","slug":"_1-如果obj里面有时间对象-则json-stringify后再json-parse的结果-时间将只是字符串的形式-而不是对象的形式","link":"#_1-如果obj里面有时间对象-则json-stringify后再json-parse的结果-时间将只是字符串的形式-而不是对象的形式","children":[]},{"level":3,"title":"2.如果obj里有函数，undefined，则序列化的结果会把函数或 undefined丢失；","slug":"_2-如果obj里有函数-undefined-则序列化的结果会把函数或-undefined丢失","link":"#_2-如果obj里有函数-undefined-则序列化的结果会把函数或-undefined丢失","children":[]},{"level":3,"title":"3.如果被拷贝的对象中有正则表达式，则拷贝之后的对象正则表达式会变成Object","slug":"_3-如果被拷贝的对象中有正则表达式-则拷贝之后的对象正则表达式会变成object","link":"#_3-如果被拷贝的对象中有正则表达式-则拷贝之后的对象正则表达式会变成object","children":[]},{"level":3,"title":"4、JSON.stringify()只能序列化对象的可枚举的自有属性，例如 如果obj中的对象是有构造函数生成的， 则使用JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的constructor；  会抛弃对象的constructor,所有的构造函数会指向Object","slug":"_4、json-stringify-只能序列化对象的可枚举的自有属性-例如-如果obj中的对象是有构造函数生成的-则使用json-parse-json-stringify-obj-深拷贝后-会丢弃对象的constructor-会抛弃对象的constructor-所有的构造函数会指向object","link":"#_4、json-stringify-只能序列化对象的可枚举的自有属性-例如-如果obj中的对象是有构造函数生成的-则使用json-parse-json-stringify-obj-深拷贝后-会丢弃对象的constructor-会抛弃对象的constructor-所有的构造函数会指向object","children":[]}],"git":{"updatedTime":1706239173000,"contributors":[{"name":"qdleader","email":"yk4545945@163.com","commits":1}]},"filePathRelative":"前端面试/js类/其他类/JSON.stringfy和JSON.parse的弊端.md"}');export{e as data};
